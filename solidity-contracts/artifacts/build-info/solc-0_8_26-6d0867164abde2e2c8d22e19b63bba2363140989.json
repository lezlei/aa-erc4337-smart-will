{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_26-6d0867164abde2e2c8d22e19b63bba2363140989",
  "solcVersion": "0.8.26",
  "solcLongVersion": "0.8.26+commit.8a97fa7a",
  "userSourceNameMap": {
    "contracts/WillModule.sol": "project/contracts/WillModule.sol",
    "contracts/interfaces/ISafe.sol": "project/contracts/interfaces/ISafe.sol",
    "contracts/interfaces/ISafeProxyFactory.sol": "project/contracts/interfaces/ISafeProxyFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/interfaces/ISafe.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\n// This file now contains everything your module needs to know about a Safe.\n// It is completely self-contained and requires no external imports.\n\nlibrary Enum {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n}\n\ninterface ISafe {\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation\n    ) external returns (bool success);\n}"
      },
      "project/contracts/interfaces/ISafeProxyFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\ninterface ISafeProxyFactory {\n    /**\n     * @notice Creates a new proxy contract that points to a singleton mastercopy.\n     * @param _singleton The address of the mastercopy contract (the Safe L2 blueprint).\n     * @param data The calldata used to initialize the new proxy (the setup instructions).\n     * @return proxy The address of the newly created proxy contract.\n     */\n    function createProxy(address _singleton, bytes calldata data)\n        external\n        returns (address proxy);\n}"
      },
      "project/contracts/WillModule.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\nimport \"./interfaces/ISafe.sol\";\nimport \"./interfaces/ISafeProxyFactory.sol\";\n\ncontract WillModule {\n    // Variables\n    mapping(address => Will) willData;\n\n    struct Will {\n        uint256 lastPing; // The timestamp of the last \"I'm alive\" signal\n        uint256 timeout; // Length of time after lastPing for beneficiaries to be able to claim\n        mapping(bytes32 => uint256) inheritances; // Mapping of beneficiary ID to their inheritance amount\n        bytes32[] beneficiaryList; // List of beneficiaries\n    }\n\n    // Errors\n    error WillNotFound(address owner);\n    error BeneficiaryExists(bytes32 beneficiary);\n    error BeneficiaryNotFound(bytes32 beneficiary);\n    error TimeoutNotExpired(uint256 unlockTime);\n    error NothingToClaim();\n    error NoValueSent();\n    error UnviableAmount();\n    error TimeoutMustBeMoreThan0();\n    error WillAlreadyExists();\n\n    // --- Events ---\n    event WillCreated(address indexed owner, uint256 timeout);\n    event Ping(address indexed owner);\n    event BeneficiaryAdded(address indexed owner, bytes32 indexed beneficiary, uint256 amount);\n    event BeneficiaryUpdated(address indexed owner, bytes32 indexed beneficiary, uint256 newAmount);\n    event BeneficiaryRemoved(address indexed owner, bytes32 indexed beneficiary);\n    event InheritanceClaimed(address indexed owner, bytes32 indexed beneficiary, address newSafe, uint256 amount);\n\n    /**\n     * @notice Creates a will for the calling Safe account.\n     * @dev Can only be called once per Safe. The caller must be the Safe itself,\n     * which is the msg.sender in a module context.\n     * @param _timeoutInDays The number of days of inactivity before the will can be executed.\n     */\n    function createWill(uint256 _timeoutInDays) external {\n        address safe = msg.sender;\n\n        if (willData[msg.sender].lastPing > 0) {\n            revert WillAlreadyExists();\n        }\n        if (_timeoutInDays <= 0) {\n            revert TimeoutMustBeMoreThan0();\n        }\n\n        willData[safe].lastPing = block.timestamp;\n        willData[safe].timeout = _timeoutInDays * 1 days;\n\n        emit WillCreated(safe, _timeoutInDays * 1 days);\n    }\n\n    /**\n     * @notice Resets the inactivity timer for the calling Safe's will.\n     * @dev The caller (msg.sender) must be a Safe account with an existing will.\n     */\n    function ping() external {\n        address safe = msg.sender;\n\n        if (willData[safe].timeout == 0) {\n            revert WillNotFound(safe);\n        }\n\n        willData[safe].lastPing = block.timestamp;\n        emit Ping(safe);\n    }\n\n    /**\n     * @notice Adds a beneficiary to the calling Safe's will.\n     * @dev The caller (msg.sender) must be a Safe account with an existing will.\n     * @param _beneficiary The keccak256 hash of the beneficiary's off-chain identifier to add.\n     * @param _amount The inheritance amount in wei.\n     */\n    function addBeneficiary(bytes32 _beneficiary, uint256 _amount) external {\n        address safe = msg.sender;\n        Will storage userWill = willData[safe];\n\n        if (userWill.timeout == 0) {\n            revert WillNotFound(safe);\n        }\n        if (_amount == 0) {\n            revert UnviableAmount();\n        }\n        if (userWill.inheritances[_beneficiary] > 0) {\n            revert BeneficiaryExists(_beneficiary);\n        }\n        \n        userWill.inheritances[_beneficiary] = _amount;\n        userWill.beneficiaryList.push(_beneficiary);\n        userWill.lastPing = block.timestamp; \n        emit BeneficiaryAdded(safe, _beneficiary, _amount);\n    }\n\n    /**\n     * @notice Removes a beneficiary from the calling Safe's will.\n     * @dev Uses the 'swap and pop' method for efficient array removal.\n     * @param _beneficiary The keccak256 hash of the beneficiary's off-chain identifier to remove.\n     */\n    function removeBeneficiary(bytes32 _beneficiary) external {\n        address safe = msg.sender;\n        Will storage userWill = willData[safe];\n\n        // --- Checks ---\n        if (userWill.timeout == 0) {\n            revert WillNotFound(safe);\n        }\n        if (userWill.inheritances[_beneficiary] == 0) {\n            revert BeneficiaryNotFound(_beneficiary);\n        }\n\n        delete userWill.inheritances[_beneficiary];\n        \n        // \"Swap and Pop\" to remove from the array\n        for (uint256 i = 0; i < userWill.beneficiaryList.length; i++) {\n            if (userWill.beneficiaryList[i] == _beneficiary) {\n                // Swap the element to remove with the last element\n                userWill.beneficiaryList[i] = userWill.beneficiaryList[userWill.beneficiaryList.length - 1];\n                // Remove the last element\n                userWill.beneficiaryList.pop();\n                break;\n            }\n        }\n        \n        userWill.lastPing = block.timestamp;\n        emit BeneficiaryRemoved(safe, _beneficiary);\n    }\n\n    /**\n     * @notice Updates the inheritance amount for an existing beneficiary using their private identifier.\n     * @param _beneficiary The keccak256 hash of the beneficiary's unique off-chain identifier.\n     * @param _newAmount The new inheritance amount in wei.\n     */\n    function updateBeneficiary(bytes32 _beneficiary, uint256 _newAmount) external {\n        address safe = msg.sender;\n        Will storage userWill = willData[safe];\n\n        if (userWill.timeout == 0) {\n            revert WillNotFound(safe);\n        }\n        if (userWill.inheritances[_beneficiary] == 0) {\n            revert BeneficiaryNotFound(_beneficiary);\n        }\n        if (_newAmount == 0) {\n            revert UnviableAmount();\n        }\n\n        userWill.inheritances[_beneficiary] = _newAmount;\n        userWill.lastPing = block.timestamp;\n        emit BeneficiaryUpdated(safe, _beneficiary, _newAmount);\n    }\n\n    /**\n     * @notice Allows a beneficiary to claim their inheritance. This action creates a new Safe\n     * for the beneficiary and transfers their inheritance from the owner's Safe.\n     * @param _ownerSafeAddress The address of the will owner's Safe account.\n     * @param _beneficiarySecret A unique off-chain secret (e.g., \"charmander@gmail.com\").\n     * @param _newSafeOwner The address that will own the newly created Safe for the beneficiary.\n     */\n    function claimInheritance(address _ownerSafeAddress, string calldata _beneficiarySecret, address _newSafeOwner) external {\n        Will storage ownerWill = willData[_ownerSafeAddress];\n        // --- 1. The Checks ---\n        if (ownerWill.timeout == 0) {\n            revert WillNotFound(_ownerSafeAddress);\n        }\n        if (block.timestamp < ownerWill.lastPing + ownerWill.timeout) {\n            revert TimeoutNotExpired(ownerWill.lastPing + ownerWill.timeout);\n        }\n\n        // Hash the secret to get the beneficiary ID\n        bytes32 beneficiaryId = keccak256(abi.encodePacked(_beneficiarySecret));\n        \n        uint256 inheritanceAmount = ownerWill.inheritances[beneficiaryId];\n        if (inheritanceAmount == 0) {\n            revert NothingToClaim();\n        }\n\n        // --- 2. New Safe Creation for Beneficiary ---\n        address safeSingleton = 0x29fcB43b46531BcA003ddC8FCB67FFE91900C762; // Arb Sepolia\n        address safeFactory = 0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67;   // Arb Sepolia\n\n        address[] memory owners = new address[](1);\n        owners[0] = _newSafeOwner;\n\n        // Initializes the new Safe, setting `_newSafeOwner` as the owner.\n        bytes memory setupData = abi.encodeWithSignature(\n            // The function signature as a string literal\n            \"setup(address[],uint256,address,bytes,address,address,uint256,address)\",\n\n            // Argument 1: The owners array\n            _newSafeOwner,\n\n            // Argument 2: Threshold of 1 since there's a single owner\n            1,\n\n            // Arguments 3-8: The optional parameters, set to zero/empty\n            address(0),\n            \"\",\n            address(0),\n            address(0),\n            0,\n            address(0)\n            );\n\n        // Calls the factory to create the new Safe for the beneficiary and returns \n        // the address of the newly created Safe. \n        address newBeneficiarySafe = ISafeProxyFactory(safeFactory).createProxy(safeSingleton, setupData);\n\n        // --- 3. The Payout ---\n        // Commands the owner's Safe to send the inheritance to the new Safe.\n        bool success = ISafe(payable(_ownerSafeAddress)).execTransactionFromModule(\n            newBeneficiarySafe, \n            inheritanceAmount, \n            \"\", \n            Enum.Operation.Call);\n        require(success, \"WillModule: Payout from owner's Safe failed\");\n        \n        // --- 4. Admin ---\n        delete ownerWill.inheritances[beneficiaryId];\n        for (uint256 i = 0; i < ownerWill.beneficiaryList.length; i++) {\n            if (ownerWill.beneficiaryList[i] == beneficiaryId) {\n                ownerWill.beneficiaryList[i] = ownerWill.beneficiaryList[ownerWill.beneficiaryList.length - 1];\n                ownerWill.beneficiaryList.pop();\n                break;\n            }\n        }\n        emit InheritanceClaimed(_ownerSafeAddress, beneficiaryId, newBeneficiarySafe, inheritanceAmount);\n    }\n}"
      }
    }
  }
}